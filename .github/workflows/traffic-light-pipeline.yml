name: Traffic Light Pipeline

on:
  workflow_call:
    inputs:
      ci-tool:
        required: true
        type: string
      default-cloud-provider:
        required: true
        type: string
    secrets:
      terraform-cloud-token:
        required: true
      github-token:
        required: true
      civo-token:
        required: false
      oci-tenancy-ocid:
        required: false
      oci-user-ocid:
        required: false
      oci-fingerprint:
        required: false
      oci-private-key:
        required: false
      oci-region:
        required: false
      oci-compartment-id:
        required: false

jobs:
  commit-check:
    runs-on: ubuntu-latest
    outputs:
      should-run: ${{ steps.check.outputs.should-run }}
      cloud-provider: ${{ steps.check.outputs.cloud-provider }}
      is-release: ${{ steps.check.outputs.is-release }}
    steps:
    - uses: actions/checkout@v4
    
    - name: Parse commit message
      id: check
      run: |
        # Get commit message based on event type
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          COMMIT_MSG="${{ github.event.pull_request.title }}"
          echo "PR Title: $COMMIT_MSG"
        else
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          echo "Commit message: $COMMIT_MSG"
        fi
        
        # Check if this pipeline should run
        if [[ "$COMMIT_MSG" == *"[${{ inputs.ci-tool }}]"* ]]; then
          echo "‚úÖ ${{ inputs.ci-tool }} should handle this"
          echo "should-run=true" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Skipping - [${{ inputs.ci-tool }}] not found as CI tool"
          echo "should-run=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Determine cloud provider
        if [[ "$COMMIT_MSG" == *"[azure]"* ]]; then
          CLOUD_PROVIDER="azure"
        elif [[ "$COMMIT_MSG" == *"[aws]"* ]]; then
          CLOUD_PROVIDER="aws"
        elif [[ "$COMMIT_MSG" == *"[civo]"* ]]; then
          CLOUD_PROVIDER="civo"
        elif [[ "$COMMIT_MSG" == *"[oci]"* ]]; then
          CLOUD_PROVIDER="oci"
        else
          CLOUD_PROVIDER="${{ inputs.default-cloud-provider }}"
        fi
        
        echo "cloud-provider=$CLOUD_PROVIDER" >> $GITHUB_OUTPUT
        
        # Determine action
        if [[ "$COMMIT_MSG" == *"[release]"* ]]; then
          echo "is-release=true" >> $GITHUB_OUTPUT
        else
          echo "is-release=false" >> $GITHUB_OUTPUT
        fi

  build:
    needs: commit-check
    if: needs.commit-check.outputs.should-run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
    - uses: actions/checkout@v4
    
    - name: Cache Terraform
      uses: actions/cache@v4
      with:
        path: |
          ~/.terraform.d/
          **/.terraform/
        key: terraform-${{ runner.os }}-${{ hashFiles('**/*.tf', '**/.terraform.lock.hcl') }}
        restore-keys: |
          terraform-${{ runner.os }}-
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
        cli_config_credentials_token: ${{ secrets.terraform-cloud-token }}
    
    - name: Install Checkov
      run: pip3 install checkov
    
    - name: Validate Terraform
      env:
        CIVO_TOKEN: ${{ secrets.civo-token }}
        TF_VAR_compartment_id: ${{ secrets.oci-compartment-id }}
        TF_VAR_tenancy_ocid: ${{ secrets.oci-tenancy-ocid }}
        TF_VAR_user_ocid: ${{ secrets.oci-user-ocid }}
        TF_VAR_fingerprint: ${{ secrets.oci-fingerprint }}
        TF_VAR_private_key: ${{ secrets.oci-private-key }}
        TF_VAR_region: ${{ secrets.oci-region }}
        TF_IN_AUTOMATION: "true"
        TF_INPUT: "false"
      run: |
        set -euo pipefail  # Fail fast with better error handling
        
        CLOUD_PROVIDER="${{ needs.commit-check.outputs.cloud-provider }}"
        echo "Validating $CLOUD_PROVIDER module..."
        
        # Test example if exists
        if [ -d "examples/${CLOUD_PROVIDER}-example" ]; then
          echo "‚Üí Testing example configuration..."
          cd "examples/${CLOUD_PROVIDER}-example"
          terraform init -input=false
          terraform validate
          terraform plan -input=false -detailed-exitcode || {
            echo "‚ùå Terraform plan failed or detected changes"
            exit 1
          }
          cd ../..
        fi
        
        # Test module
        if [ -d "iac/terraform/${CLOUD_PROVIDER}" ]; then
          echo "‚Üí Testing module..."
          cd "iac/terraform/${CLOUD_PROVIDER}"
          terraform init -input=false
          terraform validate
          terraform fmt -check -diff
          echo "‚Üí Running security scan..."
          checkov -d . --framework terraform --compact --quiet
          cd ../../..
        fi
        
        echo "‚úÖ All validations passed"
        
    - name: Upload Terraform Plans
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plans-${{ needs.commit-check.outputs.cloud-provider }}
        path: |
          **/*.tfplan
          **/terraform.log
        retention-days: 7

  create-pr:
    needs: [commit-check, build]
    if: needs.commit-check.outputs.is-release == 'true' && github.ref != 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
    - uses: actions/checkout@v4
    
    - name: Create Release PR
      run: |
        CLOUD_PROVIDER="${{ needs.commit-check.outputs.cloud-provider }}"
        BRANCH_NAME="${{ github.ref_name }}"
        
        gh pr create \
          --title "Release: ${CLOUD_PROVIDER} module updates" \
          --body "Automated release PR

        Approve with: [APPROVED] [PATCH] [${{ inputs.ci-tool }}]" \
          --base main \
          --head "$BRANCH_NAME"
        
        echo "‚úÖ Release PR created"
      env:
        GITHUB_TOKEN: ${{ secrets.github-token }}

  publish:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Publish Module
      run: |
        MERGE_MSG="${{ github.event.head_commit.message }}"
        echo "Merge message: $MERGE_MSG"
        
        # Check if this tool should publish
        if [[ "$MERGE_MSG" != *"[${{ inputs.ci-tool }}]"* ]]; then
          echo "‚ùå Skipping publish - not approved for ${{ inputs.ci-tool }}"
          exit 0
        fi
        
        echo "‚úÖ Publishing module..."
        
        # Determine version bump
        if [[ "$MERGE_MSG" == *"[MAJOR]"* ]]; then
          BUMP_TYPE="major"
        elif [[ "$MERGE_MSG" == *"[MINOR]"* ]]; then
          BUMP_TYPE="minor"
        else
          BUMP_TYPE="patch"
        fi
        
        # Get current version and bump
        git fetch --tags
        LATEST_TAG=$(git tag -l "v*" | sort -V | tail -n1)
        
        if [ -z "$LATEST_TAG" ]; then
          NEW_VERSION="0.0.1"
        else
          CURRENT_VERSION=${LATEST_TAG#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          case $BUMP_TYPE in
            major) NEW_VERSION="$((MAJOR + 1)).0.0" ;;
            minor) NEW_VERSION="$MAJOR.$((MINOR + 1)).0" ;;
            patch) NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))" ;;
          esac
        fi
        
        # Configure git
        git config --global user.email "action@github.com"
        git config --global user.name "${{ inputs.ci-tool }}"
        
        # Create and push tag
        git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
        git push origin "v$NEW_VERSION"
        
        echo "üöÄ Published version: v$NEW_VERSION"
      env:
        GITHUB_TOKEN: ${{ secrets.github-token }}